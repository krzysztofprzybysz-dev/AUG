This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitattributes
Makefile
parser.y
README.md
scanner.l
tree.c
tree.h
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitattributes">
# Auto detect text files and perform LF normalization
* text=auto
</file>

<file path="Makefile">
# Makefile dla Pretty Printer WyraÅ¼eÅ„ Arytmetycznych
# Autor: [Twoje imiÄ™ i nazwisko]
# Data: 2025

# Kompilator i flagi
CC = gcc
CFLAGS = -Wall -Wextra -g -std=c11 -D_GNU_SOURCE
LEX = flex
YACC = bison

# Nazwa programu wykonywalnego
TARGET = pretty_printer

# Pliki ÅºrÃ³dÅ‚owe
SOURCES = parser.tab.c lex.yy.c tree.c
OBJECTS = $(SOURCES:.c=.o)
HEADERS = tree.h parser.tab.h

# GÅ‚Ã³wna reguÅ‚a
all: $(TARGET)

# Kompilacja programu wykonywalnego
$(TARGET): parser.tab.h lex.yy.c $(OBJECTS)
	$(CC) $(CFLAGS) -o $@ $(OBJECTS)
	@echo "âœ… Kompilacja zakoÅ„czona sukcesem!"
	@echo "ğŸ“‹ Uruchom program poleceniem: ./$(TARGET)"

# Generowanie parsera
parser.tab.c parser.tab.h: parser.y
	$(YACC) -d parser.y

# Generowanie skanera
lex.yy.c: scanner.l parser.tab.h
	$(LEX) scanner.l

# Kompilacja plikÃ³w obiektowych
%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

# ZaleÅ¼noÅ›ci
lex.yy.o: lex.yy.c parser.tab.h tree.h
parser.tab.o: parser.tab.c tree.h
tree.o: tree.c tree.h parser.tab.h

# Uruchomienie programu
run: $(TARGET)
	./$(TARGET)

# Testy
test: $(TARGET)
	@echo "ğŸ§ª Uruchamianie testÃ³w..."
	@echo "Test 1: 2+3*4"
	@echo "2+3*4" | ./$(TARGET)
	@echo "\nTest 2: (2+3)*4"
	@echo "(2+3)*4" | ./$(TARGET)
	@echo "\nTest 3: 2^3+1"
	@echo "2^3+1" | ./$(TARGET)
	@echo "\nTest 4: -5+10"
	@echo "-5+10" | ./$(TARGET)

# Czyszczenie
clean:
	rm -f $(TARGET) $(OBJECTS) lex.yy.c parser.tab.c parser.tab.h
	@echo "ğŸ§¹ Wyczyszczono pliki tymczasowe"

# PeÅ‚ne czyszczenie (wÅ‚Ä…cznie z plikami generowanymi przez edytory)
distclean: clean
	rm -f *~ *.swp *.bak

# Pomoc
help:
	@echo "ğŸ“– DostÄ™pne komendy:"
	@echo "  make        - kompiluje program"
	@echo "  make run    - kompiluje i uruchamia program"
	@echo "  make test   - uruchamia przykÅ‚adowe testy"
	@echo "  make clean  - usuwa pliki tymczasowe"
	@echo "  make help   - wyÅ›wietla tÄ™ pomoc"

.PHONY: all run test clean distclean help
</file>

<file path="README.md">
Pretty Printer WyraÅ¼eÅ„ Arytmetycznych
ğŸ“‹ Opis projektu
Pretty Printer to program napisany przy uÅ¼yciu narzÄ™dzi Lex (Flex) i Yacc (Bison), ktÃ³ry analizuje wyraÅ¼enia arytmetyczne i wyÅ›wietla je w formie drzewa skÅ‚adniowego ASCII-art. Program dodatkowo oblicza wartoÅ›Ä‡ wprowadzonego wyraÅ¼enia.
GÅ‚Ã³wne funkcjonalnoÅ›ci:

âœ… Parsowanie wyraÅ¼eÅ„ arytmetycznych
âœ… Budowanie drzewa skÅ‚adniowego (AST - Abstract Syntax Tree)
âœ… WyÅ›wietlanie drzewa w formie ASCII-art z liniami Å‚Ä…czÄ…cymi
âœ… Obliczanie wartoÅ›ci wyraÅ¼enia
âœ… ObsÅ‚uga bÅ‚Ä™dÃ³w skÅ‚adniowych

ObsÅ‚ugiwane operacje:

Dodawanie (+)
Odejmowanie (-)
MnoÅ¼enie (*)
Dzielenie (/)
PotÄ™gowanie (^)
Negacja (jednoargumentowy -)
Nawiasy () do zmiany kolejnoÅ›ci dziaÅ‚aÅ„

ğŸ› ï¸ Wymagania systemowe

System operacyjny: Linux/Unix/macOS
Kompilator: GCC
Flex: >= 2.5
Bison: >= 3.0
Make: do automatycznej kompilacji

Instalacja zaleÅ¼noÅ›ci (Ubuntu/Debian):
bashsudo apt-get update
sudo apt-get install build-essential flex bison
ğŸš€ Kompilacja i uruchomienie
Metoda 1: UÅ¼ywajÄ…c Makefile (zalecana)
bash# Kompilacja
make

# Uruchomienie
make run

# Uruchomienie testÃ³w
make test

# Czyszczenie
make clean
Metoda 2: RÄ™czna kompilacja
bash# Generowanie skanera
flex scanner.l

# Generowanie parsera
bison -d parser.y

# Kompilacja
gcc -o pretty_printer parser.tab.c lex.yy.c tree.c

# Uruchomienie
./pretty_printer
ğŸ“– Instrukcja uÅ¼ycia

Uruchom program poleceniem ./pretty_printer
WprowadÅº wyraÅ¼enie arytmetyczne i naciÅ›nij Enter
Program wyÅ›wietli:

Drzewo skÅ‚adniowe w formie ASCII-art z liniami Å‚Ä…czÄ…cymi
Obliczony wynik wyraÅ¼enia


Wpisz pustÄ… liniÄ™, aby zakoÅ„czyÄ‡ program

PrzykÅ‚ady wyraÅ¼eÅ„:
2+3*4
(2+3)*4
10/2-3
2^3+1
-5+10
(10-4)/(3-1)
ğŸ“ Struktura projektu
.
â”œâ”€â”€ scanner.l       # Analizator leksykalny (Flex)
â”œâ”€â”€ parser.y        # Parser (Bison)
â”œâ”€â”€ tree.h          # Definicje struktur drzewa AST
â”œâ”€â”€ tree.c          # Implementacja funkcji drzewa
â”œâ”€â”€ Makefile        # Plik automatyzacji kompilacji
â”œâ”€â”€ README.md       # Dokumentacja projektu
â””â”€â”€ examples/       # PrzykÅ‚adowe wyraÅ¼enia (opcjonalnie)
ğŸ—ï¸ Architektura programu
1. Analizator leksykalny (scanner.l)

Rozpoznaje tokeny: liczby, operatory, nawiasy
Przekazuje tokeny do parsera
ObsÅ‚uguje bÅ‚Ä™dy leksykalne

2. Parser (parser.y)

Implementuje gramatykÄ™ wyraÅ¼eÅ„ arytmetycznych
Buduje drzewo skÅ‚adniowe (AST)
ZarzÄ…dza pierwszeÅ„stwem operatorÃ³w

3. Drzewo skÅ‚adniowe (tree.h/tree.c)

Struktury danych reprezentujÄ…ce wÄ™zÅ‚y drzewa
Funkcje tworzenia wÄ™zÅ‚Ã³w
Funkcja wyÅ›wietlania drzewa w formie ASCII-art
Funkcja obliczania wartoÅ›ci wyraÅ¼enia

ğŸ¯ Rozszerzenia wzglÄ™dem podstawowej wersji

Operator potÄ™gowania (^) - prawostronna Å‚Ä…cznoÅ›Ä‡
Operator negacji (-) - jednoargumentowy
Eleganckie wyÅ›wietlanie drzewa - ASCII-art z liniami Å‚Ä…czÄ…cymi
Obliczanie wartoÅ›ci wyraÅ¼enia
Lepsza obsÅ‚uga bÅ‚Ä™dÃ³w z recovery
Czytelny interfejs uÅ¼ytkownika z emoji
Dokumentacja kodu i komentarze

ğŸ› ObsÅ‚uga bÅ‚Ä™dÃ³w
Program obsÅ‚uguje nastÄ™pujÄ…ce bÅ‚Ä™dy:

BÅ‚Ä™dy skÅ‚adniowe (np. brakujÄ…ce nawiasy)
Dzielenie przez zero
Nierozpoznane znaki
BÅ‚Ä™dy alokacji pamiÄ™ci

ğŸ“Š PrzykÅ‚ad dziaÅ‚ania
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           Pretty Printer WyraÅ¼eÅ„ Arytmetycznych               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

> (5+3)*2

===== ANALIZA WYRAÅ»ENIA =====

ğŸ“Š Drzewo skÅ‚adniowe:
â””â”€â”€ [*]
    â”œâ”€â”€ [+]
    â”‚   â”œâ”€â”€ 5
    â”‚   â””â”€â”€ 3
    â””â”€â”€ 2

ğŸ§® Obliczony wynik: 16

=============================
ğŸ‘¨â€ğŸ’» Autor
[Twoje imiÄ™ i nazwisko]
ğŸ“„ Licencja
Ten projekt zostaÅ‚ stworzony w celach edukacyjnych.
</file>

<file path="parser.y">
%{

#include <stdio.h>
#include <stdlib.h>
#include "tree.h"

// Deklaracje funkcji
int yylex(void);
void yyerror(const char *s);

// Zmienna globalna przechowujÄ…ca tryb wyÅ›wietlania
int display_mode = 0; // 0 - proste drzewo, 1 - Å‚adne drzewo
%}

/* Definicja unii dla wartoÅ›ci semantycznych */
%union {
    struct Node* node;
}

/* Definicja tokenÃ³w */
%token <node> NUMBER
%token EOL

/* Definicja typÃ³w dla symboli nieterminalnych */
%type <node> expr

/* Definicja pierwszeÅ„stwa i Å‚Ä…cznoÅ›ci operatorÃ³w */
%left '+' '-'
%left '*' '/'
%right '^'        /* PotÄ™gowanie - prawostronne */
%right UNARY      /* Negacja - najwyÅ¼szy priorytet */

%%
/* === REGUÅY GRAMATYKI === */

program:
      /* program moÅ¼e byÄ‡ pusty */
    | program line
    ;

line:
      EOL                 /* pusta linia */
    | expr EOL            {
                            printf("\n===== ANALIZA WYRAÅ»ENIA =====\n");
                            
                            // WyÅ›wietl drzewo skÅ‚adniowe
                            printf("\nğŸ“Š Drzewo skÅ‚adniowe:\n");
                            print_tree_pretty($1, "", 1);
                            
                            // Oblicz i wyÅ›wietl wynik
                            printf("\nğŸ§® Obliczony wynik: %d\n", evaluate_tree($1));
                            
                            printf("\n=============================\n\n");
                            
                            // Zwolnij pamiÄ™Ä‡
                            free_tree($1);
                          }
    | error EOL           {
                            fprintf(stderr, "Pomijam bÅ‚Ä™dne wyraÅ¼enie. SprÃ³buj ponownie.\n");
                            yyerrok;  // Zresetuj stan bÅ‚Ä™du
                          }
    ;

expr:
      NUMBER              { $$ = $1; }
    | expr '+' expr       { $$ = create_operator_node('+', $1, $3); }
    | expr '-' expr       { $$ = create_operator_node('-', $1, $3); }
    | expr '*' expr       { $$ = create_operator_node('*', $1, $3); }
    | expr '/' expr       {
                            // MoÅ¼emy dodaÄ‡ sprawdzenie dzielenia przez zero juÅ¼ tutaj
                            $$ = create_operator_node('/', $1, $3);
                          }
    | expr '^' expr       { $$ = create_operator_node('^', $1, $3); }
    | '-' expr %prec UNARY { $$ = create_unary_node('-', $2); }
    | '(' expr ')'        { $$ = $2; }
    ;

%%
/* === KOD C === */

/**
 * @brief Funkcja gÅ‚Ã³wna programu
 */
int main(void) {
    printf("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘           Pretty Printer WyraÅ¼eÅ„ Arytmetycznych               â•‘\n");
    printf("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n");
    printf("â•‘ ObsÅ‚ugiwane operacje:                                         â•‘\n");
    printf("â•‘   â€¢ Dodawanie (+)        â€¢ Odejmowanie (-)                   â•‘\n");
    printf("â•‘   â€¢ MnoÅ¼enie (*)         â€¢ Dzielenie (/)                     â•‘\n");
    printf("â•‘   â€¢ PotÄ™gowanie (^)      â€¢ Negacja (-)                       â•‘\n");
    printf("â•‘   â€¢ Nawiasy ()                                                â•‘\n");
    printf("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n");
    printf("â•‘ PrzykÅ‚ady:                                                    â•‘\n");
    printf("â•‘   â€¢ (5+3)*2              â€¢ -5+10                              â•‘\n");
    printf("â•‘   â€¢ 2^3+1                â€¢ (10-4)/(3-1)                       â•‘\n");
    printf("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n");
    printf("â•‘ Wpisz wyraÅ¼enie i naciÅ›nij Enter. Pusta linia koÅ„czy program.â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");
    
    yyparse();
    
    printf("\nDziÄ™kujemy za skorzystanie z programu!\n");
    return 0;
}

/**
 * @brief Funkcja obsÅ‚ugi bÅ‚Ä™dÃ³w parsera
 * @param s Komunikat o bÅ‚Ä™dzie
 */
void yyerror(const char *s) {
    fprintf(stderr, "âŒ BÅ‚Ä…d parsowania: %s\n", s);
}
</file>

<file path="scanner.l">
%{

#include "parser.tab.h"  // Definicje tokenÃ³w generowane przez Bison
#include "tree.h"        // Definicje struktur drzewa
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// Licznik linii (przydatny przy debugowaniu)
int line_number = 1;
%}

/* Definicje pomocnicze */
DIGIT       [0-9]
NUMBER      {DIGIT}+
WHITESPACE  [ \t]

/* Opcje skanera */
%option noyywrap
%option nounput
%option noinput

%%
    /* === REGUÅY LEKSYKALNE === */

{NUMBER}    {
                /* Rozpoznanie liczby caÅ‚kowitej */
                yylval.node = create_number_node(atoi(yytext));
                if (yylval.node == NULL) {
                    fprintf(stderr, "BÅ‚Ä…d: Nie moÅ¼na utworzyÄ‡ wÄ™zÅ‚a dla liczby %s\n", yytext);
                    exit(1);
                }
                return NUMBER;
            }

{WHITESPACE}+ {
                /* Ignoruj biaÅ‚e znaki (spacje i tabulacje) */
            }

\n          {
                /* Koniec linii - zwiÄ™ksz licznik linii */
                line_number++;
                return EOL;
            }

"+"         { return '+'; }
"-"         { return '-'; }
"*"         { return '*'; }
"/"         { return '/'; }
"^"         { return '^'; }  /* Operator potÄ™gowania */
"("         { return '('; }
")"         { return ')'; }

.           {
                /* Nierozpoznany znak */
                fprintf(stderr, "âŒ BÅ‚Ä…d leksykalny w linii %d: Nieznany znak '%s' (ASCII: %d)\n", 
                        line_number, yytext, (unsigned char)yytext[0]);
            }

%%
</file>

<file path="tree.c">
/**
 * @file tree.c
 * @brief Implementacja funkcji do obsÅ‚ugi drzewa skÅ‚adniowego
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "tree.h"

// ZewnÄ™trzna deklaracja funkcji yyerror z parser.y
extern void yyerror(const char *s);

/**
 * @brief Tworzy nowy wÄ™zeÅ‚ przechowujÄ…cy liczbÄ™
 */
Node* create_number_node(int value) {
    Node* node = (Node*)malloc(sizeof(Node));
    if (node == NULL) {
        yyerror("BÅ‚Ä…d: Nie udaÅ‚o siÄ™ zaalokowaÄ‡ pamiÄ™ci dla wÄ™zÅ‚a liczby");
        return NULL;
    }
    node->type = TYPE_NUM;
    node->number = value;
    return node;
}

/**
 * @brief Tworzy nowy wÄ™zeÅ‚ operatora binarnego
 */
Node* create_operator_node(char op, Node* left, Node* right) {
    Node* node = (Node*)malloc(sizeof(Node));
    if (node == NULL) {
        yyerror("BÅ‚Ä…d: Nie udaÅ‚o siÄ™ zaalokowaÄ‡ pamiÄ™ci dla wÄ™zÅ‚a operatora");
        return NULL;
    }
    node->type = TYPE_OP;
    node->op_details.op = op;
    node->op_details.left = left;
    node->op_details.right = right;
    return node;
}

/**
 * @brief Tworzy nowy wÄ™zeÅ‚ operatora jednoargumentowego
 */
Node* create_unary_node(char op, Node* operand) {
    Node* node = (Node*)malloc(sizeof(Node));
    if (node == NULL) {
        yyerror("BÅ‚Ä…d: Nie udaÅ‚o siÄ™ zaalokowaÄ‡ pamiÄ™ci dla wÄ™zÅ‚a operatora jednoargumentowego");
        return NULL;
    }
    node->type = TYPE_UNARY;
    node->unary_details.op = op;
    node->unary_details.operand = operand;
    return node;
}

/**
 * @brief Zwalnia pamiÄ™Ä‡ zajmowanÄ… przez drzewo (rekurencyjnie)
 */
void free_tree(Node* node) {
    if (node == NULL) {
        return;
    }
    
    switch (node->type) {
        case TYPE_OP:
            free_tree(node->op_details.left);
            free_tree(node->op_details.right);
            break;
        case TYPE_UNARY:
            free_tree(node->unary_details.operand);
            break;
        case TYPE_NUM:
            // Liczba nie ma potomkÃ³w
            break;
    }
    
    free(node);
}

/**
 * @brief WyÅ›wietla drzewo w prostej formie ASCII (funkcja pomocnicza - nieuÅ¼ywana w gÅ‚Ã³wnym programie)
 * 
 * Ta funkcja jest zachowana jako alternatywna metoda wyÅ›wietlania drzewa.
 * W gÅ‚Ã³wnym programie uÅ¼ywamy print_tree_pretty() dla lepszej wizualizacji.
 */
void print_tree(Node* node, int level) {
    if (node == NULL) {
        return;
    }

    // Dla operatorÃ³w binarnych, najpierw wyÅ›wietl prawe poddrzewo
    if (node->type == TYPE_OP) {
        print_tree(node->op_details.right, level + 1);
    }

    // WyÅ›wietl wciÄ™cia
    for (int i = 0; i < level; i++) {
        printf("    ");
    }

    // WyÅ›wietl wartoÅ›Ä‡ wÄ™zÅ‚a
    switch (node->type) {
        case TYPE_NUM:
            printf("%d\n", node->number);
            break;
        case TYPE_OP:
            printf("%c\n", node->op_details.op);
            break;
        case TYPE_UNARY:
            printf("(%c)\n", node->unary_details.op);
            break;
    }

    // Dla operatorÃ³w, wyÅ›wietl lewe poddrzewo/operand
    if (node->type == TYPE_OP) {
        print_tree(node->op_details.left, level + 1);
    } else if (node->type == TYPE_UNARY) {
        print_tree(node->unary_details.operand, level + 1);
    }
}

/**
 * @brief WyÅ›wietla drzewo w Å‚adniejszej formie ASCII z liniami Å‚Ä…czÄ…cymi
 */
void print_tree_pretty(Node* node, const char* prefix, int is_tail) {
    if (node == NULL) {
        return;
    }

    printf("%s", prefix);
    printf("%s", is_tail ? "â””â”€â”€ " : "â”œâ”€â”€ ");
    
    // WyÅ›wietl wartoÅ›Ä‡ wÄ™zÅ‚a
    switch (node->type) {
        case TYPE_NUM:
            printf("%d\n", node->number);
            break;
        case TYPE_OP:
            printf("[%c]\n", node->op_details.op);
            break;
        case TYPE_UNARY:
            printf("[%c]\n", node->unary_details.op);
            break;
    }

    // Przygotuj przedrostek dla potomkÃ³w
    char new_prefix[256];
    snprintf(new_prefix, sizeof(new_prefix), "%s%s", prefix, is_tail ? "    " : "â”‚   ");

    // WyÅ›wietl potomkÃ³w
    if (node->type == TYPE_OP) {
        print_tree_pretty(node->op_details.left, new_prefix, 0);
        print_tree_pretty(node->op_details.right, new_prefix, 1);
    } else if (node->type == TYPE_UNARY) {
        print_tree_pretty(node->unary_details.operand, new_prefix, 1);
    }
}

/**
 * @brief Oblicza wartoÅ›Ä‡ wyraÅ¼enia reprezentowanego przez drzewo
 */
int evaluate_tree(Node* node) {
    if (node == NULL) {
        yyerror("BÅ‚Ä…d: PrÃ³ba obliczenia wartoÅ›ci NULL");
        return 0;
    }

    switch (node->type) {
        case TYPE_NUM:
            return node->number;
            
        case TYPE_OP: {
            int left_val = evaluate_tree(node->op_details.left);
            int right_val = evaluate_tree(node->op_details.right);
            
            switch (node->op_details.op) {
                case '+': return left_val + right_val;
                case '-': return left_val - right_val;
                case '*': return left_val * right_val;
                case '/': 
                    if (right_val == 0) {
                        yyerror("BÅ‚Ä…d: Dzielenie przez zero!");
                        return 0;
                    }
                    return left_val / right_val;
                case '^': {
                    // Prosty algorytm potÄ™gowania dla liczb caÅ‚kowitych
                    int result = 1;
                    for (int i = 0; i < right_val; i++) {
                        result *= left_val;
                    }
                    return result;
                }
                default:
                    yyerror("BÅ‚Ä…d: Nieznany operator");
                    return 0;
            }
        }
        
        case TYPE_UNARY: {
            int operand_val = evaluate_tree(node->unary_details.operand);
            switch (node->unary_details.op) {
                case '-': return -operand_val;
                default:
                    yyerror("BÅ‚Ä…d: Nieznany operator jednoargumentowy");
                    return 0;
            }
        }
        
        default:
            yyerror("BÅ‚Ä…d: Nieznany typ wÄ™zÅ‚a");
            return 0;
    }
}
</file>

<file path="tree.h">
/**
 * @file tree.h
 * @brief Definicje struktur i funkcji do obsÅ‚ugi drzewa skÅ‚adniowego wyraÅ¼eÅ„ arytmetycznych
 * 
 * Ten plik zawiera definicje struktur reprezentujÄ…cych wÄ™zÅ‚y drzewa AST (Abstract Syntax Tree)
 * oraz deklaracje funkcji do tworzenia, wyÅ›wietlania i zwalniania drzewa.
 */

#ifndef TREE_H
#define TREE_H

// Typ wyliczeniowy okreÅ›lajÄ…cy rodzaj wÄ™zÅ‚a w drzewie
typedef enum {
    TYPE_NUM,     // WÄ™zeÅ‚ przechowujÄ…cy liczbÄ™ caÅ‚kowitÄ…
    TYPE_OP,      // WÄ™zeÅ‚ przechowujÄ…cy operator binarny
    TYPE_UNARY    // WÄ™zeÅ‚ przechowujÄ…cy operator jednoargumentowy (rozszerzenie)
} NodeType;

// Struktura reprezentujÄ…ca wÄ™zeÅ‚ drzewa skÅ‚adniowego
typedef struct Node {
    NodeType type;  // Typ wÄ™zÅ‚a
    
    union {
        // Dane dla wÄ™zÅ‚a liczbowego
        int number;
        
        // Dane dla wÄ™zÅ‚a operatora binarnego
        struct {
            char op;                // Operator: '+', '-', '*', '/', '^'
            struct Node *left;      // Lewy operand
            struct Node *right;     // Prawy operand
        } op_details;
        
        // Dane dla wÄ™zÅ‚a operatora jednoargumentowego (rozszerzenie)
        struct {
            char op;                // Operator: '-' (negacja)
            struct Node *operand;   // Operand
        } unary_details;
    };
} Node;

// Prototypy funkcji

/**
 * @brief Tworzy nowy wÄ™zeÅ‚ przechowujÄ…cy liczbÄ™
 * @param value WartoÅ›Ä‡ liczbowa
 * @return WskaÅºnik na utworzony wÄ™zeÅ‚ lub NULL w przypadku bÅ‚Ä™du
 */
Node* create_number_node(int value);

/**
 * @brief Tworzy nowy wÄ™zeÅ‚ operatora binarnego
 * @param op Znak operatora
 * @param left WskaÅºnik na lewe poddrzewo
 * @param right WskaÅºnik na prawe poddrzewo
 * @return WskaÅºnik na utworzony wÄ™zeÅ‚ lub NULL w przypadku bÅ‚Ä™du
 */
Node* create_operator_node(char op, Node* left, Node* right);

/**
 * @brief Tworzy nowy wÄ™zeÅ‚ operatora jednoargumentowego
 * @param op Znak operatora
 * @param operand WskaÅºnik na operand
 * @return WskaÅºnik na utworzony wÄ™zeÅ‚ lub NULL w przypadku bÅ‚Ä™du
 */
Node* create_unary_node(char op, Node* operand);

/**
 * @brief WyÅ›wietla drzewo w prostej formie ASCII (funkcja pomocnicza)
 * @param node WskaÅºnik na korzeÅ„ drzewa
 * @param level Poziom zagnieÅ¼dÅ¼enia (uÅ¼ywany do wciÄ™Ä‡)
 * @note Ta funkcja jest zachowana jako alternatywna metoda wyÅ›wietlania
 */
void print_tree(Node* node, int level);

/**
 * @brief WyÅ›wietla drzewo w formie ASCII-art z liniami Å‚Ä…czÄ…cymi
 * @param node WskaÅºnik na korzeÅ„ drzewa
 * @param prefix Przedrostek do wyÅ›wietlenia
 * @param is_tail Czy wÄ™zeÅ‚ jest ostatnim dzieckiem
 * @note To jest gÅ‚Ã³wna funkcja uÅ¼ywana do wyÅ›wietlania drzewa w programie
 */
void print_tree_pretty(Node* node, const char* prefix, int is_tail);

/**
 * @brief Oblicza wartoÅ›Ä‡ wyraÅ¼enia reprezentowanego przez drzewo
 * @param node WskaÅºnik na korzeÅ„ drzewa
 * @return WartoÅ›Ä‡ wyraÅ¼enia
 */
int evaluate_tree(Node* node);

/**
 * @brief Zwalnia pamiÄ™Ä‡ zajmowanÄ… przez drzewo
 * @param node WskaÅºnik na korzeÅ„ drzewa
 */
void free_tree(Node* node);

#endif // TREE_H
</file>

</files>
