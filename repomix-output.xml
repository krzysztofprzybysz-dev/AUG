This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitattributes
Makefile
parser.y
README.md
scanner.l
tree.c
tree.h
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitattributes">
# Auto detect text files and perform LF normalization
* text=auto
</file>

<file path="Makefile">
# Makefile dla Pretty Printer Wyra≈ºe≈Ñ Arytmetycznych
# Autor: [Twoje imiƒô i nazwisko]
# Data: 2025

# Kompilator i flagi
CC = gcc
CFLAGS = -Wall -Wextra -g -std=c11 -D_GNU_SOURCE
LEX = flex
YACC = bison

# Nazwa programu wykonywalnego
TARGET = pretty_printer

# Pliki ≈∫r√≥d≈Çowe
SOURCES = parser.tab.c lex.yy.c tree.c
OBJECTS = $(SOURCES:.c=.o)
HEADERS = tree.h parser.tab.h

# G≈Ç√≥wna regu≈Ça
all: $(TARGET)

# Kompilacja programu wykonywalnego
$(TARGET): parser.tab.h lex.yy.c $(OBJECTS)
	$(CC) $(CFLAGS) -o $@ $(OBJECTS)
	@echo "‚úÖ Kompilacja zako≈Ñczona sukcesem!"
	@echo "üìã Uruchom program poleceniem: ./$(TARGET)"

# Generowanie parsera
parser.tab.c parser.tab.h: parser.y
	$(YACC) -d parser.y

# Generowanie skanera
lex.yy.c: scanner.l parser.tab.h
	$(LEX) scanner.l

# Kompilacja plik√≥w obiektowych
%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

# Zale≈ºno≈õci
lex.yy.o: lex.yy.c parser.tab.h tree.h
parser.tab.o: parser.tab.c tree.h
tree.o: tree.c tree.h parser.tab.h

# Uruchomienie programu
run: $(TARGET)
	./$(TARGET)

# Testy
test: $(TARGET)
	@echo "üß™ Uruchamianie test√≥w..."
	@echo "Test 1: 2+3*4"
	@echo "2+3*4" | ./$(TARGET)
	@echo "\nTest 2: (2+3)*4"
	@echo "(2+3)*4" | ./$(TARGET)
	@echo "\nTest 3: 2^3+1"
	@echo "2^3+1" | ./$(TARGET)
	@echo "\nTest 4: -5+10"
	@echo "-5+10" | ./$(TARGET)

# Czyszczenie
clean:
	rm -f $(TARGET) $(OBJECTS) lex.yy.c parser.tab.c parser.tab.h
	@echo "üßπ Wyczyszczono pliki tymczasowe"

# Pe≈Çne czyszczenie (w≈ÇƒÖcznie z plikami generowanymi przez edytory)
distclean: clean
	rm -f *~ *.swp *.bak

# Pomoc
help:
	@echo "üìñ Dostƒôpne komendy:"
	@echo "  make        - kompiluje program"
	@echo "  make run    - kompiluje i uruchamia program"
	@echo "  make test   - uruchamia przyk≈Çadowe testy"
	@echo "  make clean  - usuwa pliki tymczasowe"
	@echo "  make help   - wy≈õwietla tƒô pomoc"

.PHONY: all run test clean distclean help
</file>

<file path="README.md">
Pretty Printer Wyra≈ºe≈Ñ Arytmetycznych
üìã Opis projektu
Pretty Printer to program napisany przy u≈ºyciu narzƒôdzi Lex (Flex) i Yacc (Bison), kt√≥ry analizuje wyra≈ºenia arytmetyczne i wy≈õwietla je w formie drzewa sk≈Çadniowego ASCII-art. Program dodatkowo oblicza warto≈õƒá wprowadzonego wyra≈ºenia.
G≈Ç√≥wne funkcjonalno≈õci:

‚úÖ Parsowanie wyra≈ºe≈Ñ arytmetycznych
‚úÖ Budowanie drzewa sk≈Çadniowego (AST - Abstract Syntax Tree)
‚úÖ Wy≈õwietlanie drzewa w formie ASCII-art z liniami ≈ÇƒÖczƒÖcymi
‚úÖ Obliczanie warto≈õci wyra≈ºenia
‚úÖ Obs≈Çuga b≈Çƒôd√≥w sk≈Çadniowych

Obs≈Çugiwane operacje:

Dodawanie (+)
Odejmowanie (-)
Mno≈ºenie (*)
Dzielenie (/)
Potƒôgowanie (^)
Negacja (jednoargumentowy -)
Nawiasy () do zmiany kolejno≈õci dzia≈Ça≈Ñ

üõ†Ô∏è Wymagania systemowe

System operacyjny: Linux/Unix/macOS
Kompilator: GCC
Flex: >= 2.5
Bison: >= 3.0
Make: do automatycznej kompilacji

Instalacja zale≈ºno≈õci (Ubuntu/Debian):
bashsudo apt-get update
sudo apt-get install build-essential flex bison
üöÄ Kompilacja i uruchomienie
Metoda 1: U≈ºywajƒÖc Makefile (zalecana)
bash# Kompilacja
make

# Uruchomienie
make run

# Uruchomienie test√≥w
make test

# Czyszczenie
make clean
Metoda 2: Rƒôczna kompilacja
bash# Generowanie skanera
flex scanner.l

# Generowanie parsera
bison -d parser.y

# Kompilacja
gcc -o pretty_printer parser.tab.c lex.yy.c tree.c

# Uruchomienie
./pretty_printer
üìñ Instrukcja u≈ºycia

Uruchom program poleceniem ./pretty_printer
Wprowad≈∫ wyra≈ºenie arytmetyczne i naci≈õnij Enter
Program wy≈õwietli:

Drzewo sk≈Çadniowe w formie ASCII-art z liniami ≈ÇƒÖczƒÖcymi
Obliczony wynik wyra≈ºenia


Wpisz pustƒÖ liniƒô, aby zako≈Ñczyƒá program

Przyk≈Çady wyra≈ºe≈Ñ:
2+3*4
(2+3)*4
10/2-3
2^3+1
-5+10
(10-4)/(3-1)
üìÅ Struktura projektu
.
‚îú‚îÄ‚îÄ scanner.l       # Analizator leksykalny (Flex)
‚îú‚îÄ‚îÄ parser.y        # Parser (Bison)
‚îú‚îÄ‚îÄ tree.h          # Definicje struktur drzewa AST
‚îú‚îÄ‚îÄ tree.c          # Implementacja funkcji drzewa
‚îú‚îÄ‚îÄ Makefile        # Plik automatyzacji kompilacji
‚îú‚îÄ‚îÄ README.md       # Dokumentacja projektu
‚îî‚îÄ‚îÄ examples/       # Przyk≈Çadowe wyra≈ºenia (opcjonalnie)
üèóÔ∏è Architektura programu
1. Analizator leksykalny (scanner.l)

Rozpoznaje tokeny: liczby, operatory, nawiasy
Przekazuje tokeny do parsera
Obs≈Çuguje b≈Çƒôdy leksykalne

2. Parser (parser.y)

Implementuje gramatykƒô wyra≈ºe≈Ñ arytmetycznych
Buduje drzewo sk≈Çadniowe (AST)
ZarzƒÖdza pierwsze≈Ñstwem operator√≥w

3. Drzewo sk≈Çadniowe (tree.h/tree.c)

Struktury danych reprezentujƒÖce wƒôz≈Çy drzewa
Funkcje tworzenia wƒôz≈Ç√≥w
Funkcja wy≈õwietlania drzewa w formie ASCII-art
Funkcja obliczania warto≈õci wyra≈ºenia

üéØ Rozszerzenia wzglƒôdem podstawowej wersji

Operator potƒôgowania (^) - prawostronna ≈ÇƒÖczno≈õƒá
Operator negacji (-) - jednoargumentowy
Eleganckie wy≈õwietlanie drzewa - ASCII-art z liniami ≈ÇƒÖczƒÖcymi
Obliczanie warto≈õci wyra≈ºenia
Lepsza obs≈Çuga b≈Çƒôd√≥w z recovery
Czytelny interfejs u≈ºytkownika z emoji
Dokumentacja kodu i komentarze

üêõ Obs≈Çuga b≈Çƒôd√≥w
Program obs≈Çuguje nastƒôpujƒÖce b≈Çƒôdy:

B≈Çƒôdy sk≈Çadniowe (np. brakujƒÖce nawiasy)
Dzielenie przez zero
Nierozpoznane znaki
B≈Çƒôdy alokacji pamiƒôci

üìä Przyk≈Çad dzia≈Çania
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë           Pretty Printer Wyra≈ºe≈Ñ Arytmetycznych               ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

> (5+3)*2

===== ANALIZA WYRA≈ªENIA =====

üìä Drzewo sk≈Çadniowe:
‚îî‚îÄ‚îÄ [*]
    ‚îú‚îÄ‚îÄ [+]
    ‚îÇ   ‚îú‚îÄ‚îÄ 5
    ‚îÇ   ‚îî‚îÄ‚îÄ 3
    ‚îî‚îÄ‚îÄ 2

üßÆ Obliczony wynik: 16

=============================
üë®‚Äçüíª Autor
[Twoje imiƒô i nazwisko]
üìÑ Licencja
Ten projekt zosta≈Ç stworzony w celach edukacyjnych.
</file>

<file path="parser.y">
%{

#include <stdio.h>
#include <stdlib.h>
#include "tree.h"

// Deklaracje funkcji
int yylex(void);
void yyerror(const char *s);

// Zmienna globalna przechowujƒÖca tryb wy≈õwietlania
int display_mode = 0; // 0 - proste drzewo, 1 - ≈Çadne drzewo
%}

/* Definicja unii dla warto≈õci semantycznych */
%union {
    struct Node* node;
}

/* Definicja token√≥w */
%token <node> NUMBER
%token EOL

/* Definicja typ√≥w dla symboli nieterminalnych */
%type <node> expr

/* Definicja pierwsze≈Ñstwa i ≈ÇƒÖczno≈õci operator√≥w */
%left '+' '-'
%left '*' '/'
%right '^'        /* Potƒôgowanie - prawostronne */
%right UNARY      /* Negacja - najwy≈ºszy priorytet */

%%
/* === REGU≈ÅY GRAMATYKI === */

program:
      /* program mo≈ºe byƒá pusty */
    | program line
    ;

line:
      EOL                 /* pusta linia */
    | expr EOL            {
                            printf("\n===== ANALIZA WYRA≈ªENIA =====\n");
                            
                            // Wy≈õwietl drzewo sk≈Çadniowe
                            printf("\nüìä Drzewo sk≈Çadniowe:\n");
                            print_tree_pretty($1, "", 1);
                            
                            // Oblicz i wy≈õwietl wynik
                            printf("\nüßÆ Obliczony wynik: %d\n", evaluate_tree($1));
                            
                            printf("\n=============================\n\n");
                            
                            // Zwolnij pamiƒôƒá
                            free_tree($1);
                          }
    | error EOL           {
                            fprintf(stderr, "Pomijam b≈Çƒôdne wyra≈ºenie. Spr√≥buj ponownie.\n");
                            yyerrok;  // Zresetuj stan b≈Çƒôdu
                          }
    ;

expr:
      NUMBER              { $$ = $1; }
    | expr '+' expr       { $$ = create_operator_node('+', $1, $3); }
    | expr '-' expr       { $$ = create_operator_node('-', $1, $3); }
    | expr '*' expr       { $$ = create_operator_node('*', $1, $3); }
    | expr '/' expr       {
                            // Mo≈ºemy dodaƒá sprawdzenie dzielenia przez zero ju≈º tutaj
                            $$ = create_operator_node('/', $1, $3);
                          }
    | expr '^' expr       { $$ = create_operator_node('^', $1, $3); }
    | '-' expr %prec UNARY { $$ = create_unary_node('-', $2); }
    | '(' expr ')'        { $$ = $2; }
    ;

%%
/* === KOD C === */

/**
 * @brief Funkcja g≈Ç√≥wna programu
 */
int main(void) {
    printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë           Pretty Printer Wyra≈ºe≈Ñ Arytmetycznych               ‚ïë\n");
    printf("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n");
    printf("‚ïë Obs≈Çugiwane operacje:                                         ‚ïë\n");
    printf("‚ïë   ‚Ä¢ Dodawanie (+)        ‚Ä¢ Odejmowanie (-)                   ‚ïë\n");
    printf("‚ïë   ‚Ä¢ Mno≈ºenie (*)         ‚Ä¢ Dzielenie (/)                     ‚ïë\n");
    printf("‚ïë   ‚Ä¢ Potƒôgowanie (^)      ‚Ä¢ Negacja (-)                       ‚ïë\n");
    printf("‚ïë   ‚Ä¢ Nawiasy ()                                                ‚ïë\n");
    printf("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n");
    printf("‚ïë Przyk≈Çady:                                                    ‚ïë\n");
    printf("‚ïë   ‚Ä¢ (5+3)*2              ‚Ä¢ -5+10                              ‚ïë\n");
    printf("‚ïë   ‚Ä¢ 2^3+1                ‚Ä¢ (10-4)/(3-1)                       ‚ïë\n");
    printf("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n");
    printf("‚ïë Wpisz wyra≈ºenie i naci≈õnij Enter. Pusta linia ko≈Ñczy program.‚ïë\n");
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n");
    
    yyparse();
    
    printf("\nDziƒôkujemy za skorzystanie z programu!\n");
    return 0;
}

/**
 * @brief Funkcja obs≈Çugi b≈Çƒôd√≥w parsera
 * @param s Komunikat o b≈Çƒôdzie
 */
void yyerror(const char *s) {
    fprintf(stderr, "‚ùå B≈ÇƒÖd parsowania: %s\n", s);
}
</file>

<file path="scanner.l">
%{

#include "parser.tab.h"  // Definicje token√≥w generowane przez Bison
#include "tree.h"        // Definicje struktur drzewa
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// Licznik linii (przydatny przy debugowaniu)
int line_number = 1;
%}

/* Definicje pomocnicze */
DIGIT       [0-9]
NUMBER      {DIGIT}+
WHITESPACE  [ \t]

/* Opcje skanera */
%option noyywrap
%option nounput
%option noinput

%%
    /* === REGU≈ÅY LEKSYKALNE === */

{NUMBER}    {
                /* Rozpoznanie liczby ca≈Çkowitej */
                yylval.node = create_number_node(atoi(yytext));
                if (yylval.node == NULL) {
                    fprintf(stderr, "B≈ÇƒÖd: Nie mo≈ºna utworzyƒá wƒôz≈Ça dla liczby %s\n", yytext);
                    exit(1);
                }
                return NUMBER;
            }

{WHITESPACE}+ {
                /* Ignoruj bia≈Çe znaki (spacje i tabulacje) */
            }

\n          {
                /* Koniec linii - zwiƒôksz licznik linii */
                line_number++;
                return EOL;
            }

"+"         { return '+'; }
"-"         { return '-'; }
"*"         { return '*'; }
"/"         { return '/'; }
"^"         { return '^'; }  /* Operator potƒôgowania */
"("         { return '('; }
")"         { return ')'; }

.           {
                /* Nierozpoznany znak */
                fprintf(stderr, "‚ùå B≈ÇƒÖd leksykalny w linii %d: Nieznany znak '%s' (ASCII: %d)\n", 
                        line_number, yytext, (unsigned char)yytext[0]);
            }

%%
</file>

<file path="tree.c">
/**
 * @file tree.c
 * @brief Implementacja funkcji do obs≈Çugi drzewa sk≈Çadniowego
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "tree.h"

// Zewnƒôtrzna deklaracja funkcji yyerror z parser.y
extern void yyerror(const char *s);

/**
 * @brief Tworzy nowy wƒôze≈Ç przechowujƒÖcy liczbƒô
 */
Node* create_number_node(int value) {
    Node* node = (Node*)malloc(sizeof(Node));
    if (node == NULL) {
        yyerror("B≈ÇƒÖd: Nie uda≈Ço siƒô zaalokowaƒá pamiƒôci dla wƒôz≈Ça liczby");
        return NULL;
    }
    node->type = TYPE_NUM;
    node->number = value;
    return node;
}

/**
 * @brief Tworzy nowy wƒôze≈Ç operatora binarnego
 */
Node* create_operator_node(char op, Node* left, Node* right) {
    Node* node = (Node*)malloc(sizeof(Node));
    if (node == NULL) {
        yyerror("B≈ÇƒÖd: Nie uda≈Ço siƒô zaalokowaƒá pamiƒôci dla wƒôz≈Ça operatora");
        return NULL;
    }
    node->type = TYPE_OP;
    node->op_details.op = op;
    node->op_details.left = left;
    node->op_details.right = right;
    return node;
}

/**
 * @brief Tworzy nowy wƒôze≈Ç operatora jednoargumentowego
 */
Node* create_unary_node(char op, Node* operand) {
    Node* node = (Node*)malloc(sizeof(Node));
    if (node == NULL) {
        yyerror("B≈ÇƒÖd: Nie uda≈Ço siƒô zaalokowaƒá pamiƒôci dla wƒôz≈Ça operatora jednoargumentowego");
        return NULL;
    }
    node->type = TYPE_UNARY;
    node->unary_details.op = op;
    node->unary_details.operand = operand;
    return node;
}

/**
 * @brief Zwalnia pamiƒôƒá zajmowanƒÖ przez drzewo (rekurencyjnie)
 */
void free_tree(Node* node) {
    if (node == NULL) {
        return;
    }
    
    switch (node->type) {
        case TYPE_OP:
            free_tree(node->op_details.left);
            free_tree(node->op_details.right);
            break;
        case TYPE_UNARY:
            free_tree(node->unary_details.operand);
            break;
        case TYPE_NUM:
            // Liczba nie ma potomk√≥w
            break;
    }
    
    free(node);
}

/**
 * @brief Wy≈õwietla drzewo w prostej formie ASCII (funkcja pomocnicza - nieu≈ºywana w g≈Ç√≥wnym programie)
 * 
 * Ta funkcja jest zachowana jako alternatywna metoda wy≈õwietlania drzewa.
 * W g≈Ç√≥wnym programie u≈ºywamy print_tree_pretty() dla lepszej wizualizacji.
 */
void print_tree(Node* node, int level) {
    if (node == NULL) {
        return;
    }

    // Dla operator√≥w binarnych, najpierw wy≈õwietl prawe poddrzewo
    if (node->type == TYPE_OP) {
        print_tree(node->op_details.right, level + 1);
    }

    // Wy≈õwietl wciƒôcia
    for (int i = 0; i < level; i++) {
        printf("    ");
    }

    // Wy≈õwietl warto≈õƒá wƒôz≈Ça
    switch (node->type) {
        case TYPE_NUM:
            printf("%d\n", node->number);
            break;
        case TYPE_OP:
            printf("%c\n", node->op_details.op);
            break;
        case TYPE_UNARY:
            printf("(%c)\n", node->unary_details.op);
            break;
    }

    // Dla operator√≥w, wy≈õwietl lewe poddrzewo/operand
    if (node->type == TYPE_OP) {
        print_tree(node->op_details.left, level + 1);
    } else if (node->type == TYPE_UNARY) {
        print_tree(node->unary_details.operand, level + 1);
    }
}

/**
 * @brief Wy≈õwietla drzewo w ≈Çadniejszej formie ASCII z liniami ≈ÇƒÖczƒÖcymi
 */
void print_tree_pretty(Node* node, const char* prefix, int is_tail) {
    if (node == NULL) {
        return;
    }

    printf("%s", prefix);
    printf("%s", is_tail ? "‚îî‚îÄ‚îÄ " : "‚îú‚îÄ‚îÄ ");
    
    // Wy≈õwietl warto≈õƒá wƒôz≈Ça
    switch (node->type) {
        case TYPE_NUM:
            printf("%d\n", node->number);
            break;
        case TYPE_OP:
            printf("[%c]\n", node->op_details.op);
            break;
        case TYPE_UNARY:
            printf("[%c]\n", node->unary_details.op);
            break;
    }

    // Przygotuj przedrostek dla potomk√≥w
    char new_prefix[256];
    snprintf(new_prefix, sizeof(new_prefix), "%s%s", prefix, is_tail ? "    " : "‚îÇ   ");

    // Wy≈õwietl potomk√≥w
    if (node->type == TYPE_OP) {
        print_tree_pretty(node->op_details.left, new_prefix, 0);
        print_tree_pretty(node->op_details.right, new_prefix, 1);
    } else if (node->type == TYPE_UNARY) {
        print_tree_pretty(node->unary_details.operand, new_prefix, 1);
    }
}

/**
 * @brief Oblicza warto≈õƒá wyra≈ºenia reprezentowanego przez drzewo
 */
int evaluate_tree(Node* node) {
    if (node == NULL) {
        yyerror("B≈ÇƒÖd: Pr√≥ba obliczenia warto≈õci NULL");
        return 0;
    }

    switch (node->type) {
        case TYPE_NUM:
            return node->number;
            
        case TYPE_OP: {
            int left_val = evaluate_tree(node->op_details.left);
            int right_val = evaluate_tree(node->op_details.right);
            
            switch (node->op_details.op) {
                case '+': return left_val + right_val;
                case '-': return left_val - right_val;
                case '*': return left_val * right_val;
                case '/': 
                    if (right_val == 0) {
                        yyerror("B≈ÇƒÖd: Dzielenie przez zero!");
                        return 0;
                    }
                    return left_val / right_val;
                case '^': {
                    // Prosty algorytm potƒôgowania dla liczb ca≈Çkowitych
                    int result = 1;
                    for (int i = 0; i < right_val; i++) {
                        result *= left_val;
                    }
                    return result;
                }
                default:
                    yyerror("B≈ÇƒÖd: Nieznany operator");
                    return 0;
            }
        }
        
        case TYPE_UNARY: {
            int operand_val = evaluate_tree(node->unary_details.operand);
            switch (node->unary_details.op) {
                case '-': return -operand_val;
                default:
                    yyerror("B≈ÇƒÖd: Nieznany operator jednoargumentowy");
                    return 0;
            }
        }
        
        default:
            yyerror("B≈ÇƒÖd: Nieznany typ wƒôz≈Ça");
            return 0;
    }
}
</file>

<file path="tree.h">
/**
 * @file tree.h
 * @brief Definicje struktur i funkcji do obs≈Çugi drzewa sk≈Çadniowego wyra≈ºe≈Ñ arytmetycznych
 * 
 * Ten plik zawiera definicje struktur reprezentujƒÖcych wƒôz≈Çy drzewa AST (Abstract Syntax Tree)
 * oraz deklaracje funkcji do tworzenia, wy≈õwietlania i zwalniania drzewa.
 */

#ifndef TREE_H
#define TREE_H

// Typ wyliczeniowy okre≈õlajƒÖcy rodzaj wƒôz≈Ça w drzewie
typedef enum {
    TYPE_NUM,     // Wƒôze≈Ç przechowujƒÖcy liczbƒô ca≈ÇkowitƒÖ
    TYPE_OP,      // Wƒôze≈Ç przechowujƒÖcy operator binarny
    TYPE_UNARY    // Wƒôze≈Ç przechowujƒÖcy operator jednoargumentowy (rozszerzenie)
} NodeType;

// Struktura reprezentujƒÖca wƒôze≈Ç drzewa sk≈Çadniowego
typedef struct Node {
    NodeType type;  // Typ wƒôz≈Ça
    
    union {
        // Dane dla wƒôz≈Ça liczbowego
        int number;
        
        // Dane dla wƒôz≈Ça operatora binarnego
        struct {
            char op;                // Operator: '+', '-', '*', '/', '^'
            struct Node *left;      // Lewy operand
            struct Node *right;     // Prawy operand
        } op_details;
        
        // Dane dla wƒôz≈Ça operatora jednoargumentowego (rozszerzenie)
        struct {
            char op;                // Operator: '-' (negacja)
            struct Node *operand;   // Operand
        } unary_details;
    };
} Node;

// Prototypy funkcji

/**
 * @brief Tworzy nowy wƒôze≈Ç przechowujƒÖcy liczbƒô
 * @param value Warto≈õƒá liczbowa
 * @return Wska≈∫nik na utworzony wƒôze≈Ç lub NULL w przypadku b≈Çƒôdu
 */
Node* create_number_node(int value);

/**
 * @brief Tworzy nowy wƒôze≈Ç operatora binarnego
 * @param op Znak operatora
 * @param left Wska≈∫nik na lewe poddrzewo
 * @param right Wska≈∫nik na prawe poddrzewo
 * @return Wska≈∫nik na utworzony wƒôze≈Ç lub NULL w przypadku b≈Çƒôdu
 */
Node* create_operator_node(char op, Node* left, Node* right);

/**
 * @brief Tworzy nowy wƒôze≈Ç operatora jednoargumentowego
 * @param op Znak operatora
 * @param operand Wska≈∫nik na operand
 * @return Wska≈∫nik na utworzony wƒôze≈Ç lub NULL w przypadku b≈Çƒôdu
 */
Node* create_unary_node(char op, Node* operand);

/**
 * @brief Wy≈õwietla drzewo w prostej formie ASCII (funkcja pomocnicza)
 * @param node Wska≈∫nik na korze≈Ñ drzewa
 * @param level Poziom zagnie≈ºd≈ºenia (u≈ºywany do wciƒôƒá)
 * @note Ta funkcja jest zachowana jako alternatywna metoda wy≈õwietlania
 */
void print_tree(Node* node, int level);

/**
 * @brief Wy≈õwietla drzewo w formie ASCII-art z liniami ≈ÇƒÖczƒÖcymi
 * @param node Wska≈∫nik na korze≈Ñ drzewa
 * @param prefix Przedrostek do wy≈õwietlenia
 * @param is_tail Czy wƒôze≈Ç jest ostatnim dzieckiem
 * @note To jest g≈Ç√≥wna funkcja u≈ºywana do wy≈õwietlania drzewa w programie
 */
void print_tree_pretty(Node* node, const char* prefix, int is_tail);

/**
 * @brief Oblicza warto≈õƒá wyra≈ºenia reprezentowanego przez drzewo
 * @param node Wska≈∫nik na korze≈Ñ drzewa
 * @return Warto≈õƒá wyra≈ºenia
 */
int evaluate_tree(Node* node);

/**
 * @brief Zwalnia pamiƒôƒá zajmowanƒÖ przez drzewo
 * @param node Wska≈∫nik na korze≈Ñ drzewa
 */
void free_tree(Node* node);

#endif // TREE_H
</file>

</files>
